#include<stdint.h>
/*
*计算一段连续指令长度
*mode -1:16位指令系统 0:32位指令系统 1:64位指令系统
*length连续指令长度 
*/
/*flag表说明
*对于操作码一般奇数操作数都是字节型，偶数位双字节或者4字节所以，flag中高四位对应偶数操作码属性，低4位对应奇数操作码属性
*属性表只有单字节操作码和双字节操作码属性
*对于4位操作码，0位表示指令是否有modrm，高位表示立即数的位数。
*/

// branch test
// patch test
                           /*0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F*/   
uint8_t flag[256] = { /*0*/0x11,0x11,0x26,0x00,0x11,0x11,0x26,0x00,0x11,0x11,0x26,0x00,0x11,0x11,0x26,0x00,\
                      /*1*/0x11,0x11,0x26,0x00,0x11,0x11,0x26,0x00,0x11,0x11,0x26,0x00,0x11,0x11,0x26,0x00,\
                      /*2*/0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
                      /*3*/0x00,0x11,0x00,0x00,0x67,0x23,0x00,0x00,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,\
                      /*4*/0x37,0x33,0x11,0x11,0x11,0x11,0x11,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
                      /*5*/0x00,0x00,0x00,0x00,0x26,0x00,0x00,0x00,0x22,0x22,0x22,0x22,0x66,0x66,0x66,0x66,\
                      /*6*/0x33,0x40,0x11,0x37,0x80,0x40,0x02,0x00,0x11,0x11,0x22,0x00,0x11,0x11,0x11,0x11,\
                      /*7*/0x22,0x22,0x22,0x22,0x66,0x02,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x11,\
	              /*8*/0x11,0x11,0x00,0x00,0x00,0x00,0x01,0x01,0x11,0x11,0x11,0x11,0x10,0x00,0x00,0x01,\
	              /*9*/0x11,0x11,0x10,0x10,0x11,0x11,0x11,0x11,0x00,0x00,0x00,0x00,0x10,0x10,0x00,0x00,\
	              /*A*/0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,\
	              /*B*/0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x33,0x11,0x11,0x10,0x00,0x00,0x11,0x11,\
	              /*C*/0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,\
	              /*D*/0x00,0x01,0x31,0x00,0x00,0x01,0x31,0x11,0x11,0x11,0x11,0x11,0x00,0x11,0x11,0x11,\
	              /*E*/0x11,0x31,0x33,0x31,0x00,0x00,0x00,0x00,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,\
	              /*F*/0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10  };
int ldasm(uint8_t *code, uint32_t length, int32_t mode)
{
	uint32_t is_64w = 0;
	uint32_t is_movIv = 0;
	uint32_t is_16 = 0;
	uint8_t * p = code;
	uint8_t opcode=0;
	uint8_t base = 0;
	uint8_t flags=0;
	uint8_t mod=0;
	uint8_t modrm=0;
	uint8_t sib=0;
	if (!code || !length)
	{
		return -1;
	}
	do
	{
		opcode = *(p++);
		length--;
		if (((uint8_t)(opcode - 0x40) < 0xf) && (mode == 1))
		{
			is_64w = 1;
			continue;
		}
		if (opcode == 0x66)
		{
			is_16 = 1;
			continue;
		}
		if ((opcode != 0xf0) && (opcode != 0xf2) && (opcode != 0xf3) && (opcode != 0x26) && (opcode != 0x2e) && (opcode != 0x36) && (opcode != 0x36) && \
			(opcode != 0x3e) && (opcode != 0x64) && (opcode != 0x65) && (opcode != 0x67))
		{
			break;
		}
	} while (length);
	if (length == 0)
	{
		return -2;
	}
	if (opcode == 0xf)
	{
		length --;
		if (length == 0)
		{
			return -2;
		}
		opcode = *(p++);
		base = 0x80;
	}

	if (opcode == 0xb8)
	{
		is_movIv = 1;
	}

	flags = flag[base + opcode / 2];
	if (!(opcode & 1))
	{
		flags = flags >> 4;
	}
	flags &= 0xf;
	mod = flags >> 1;
	if (flags & 1)
	{
		length--;
		if (length == 0)
		{
			return -2;
		}
		modrm = *(p++);
		if ((modrm & 0xc0) != 0xc0)
		{
			if (mode != -1)
			{
				if ((modrm & 7) == 4)
				{
					length--;
					if (length == 0)
					{
						return -2;
					}
					sib = *(p++);
					if ((sib & 7) == 5)
					{
						if ((modrm & 0xc0) == 0)
						{
							p += 4;
						}
						else if ((modrm & 0xc0) == 0x40)
						{
							p += 1;
						}
						else if ((modrm & 0xc0) == 0x80)
						{
							p += 4;
						}
					}
				}
			}
			if ((modrm & 0xc0) == 0|| (modrm & 0xc0) == 0x80)
			{
				if ((modrm & 7) == 5)
				{
					p = p + (mode != -1) * 2 + 2;
				}
			}
			else if ((modrm & 0xc0) == 40)
			{
				if ((modrm & 7) == 5)
				{
					p++;
				}
			}
		}
	}
	if ((((modrm >> 3) & 7) == 1)|| (((modrm >> 3) & 7) == 0))
	{
		if (opcode == 0xf6)
		{
			mod |= 1;
		}
		else if (opcode == 0xf7)
		{
			mod |= 3;
		}
		else if ((opcode == 0x9a) || (opcode == 0xea))
		{
			p += 6;
		}
		else if ((opcode >= 0xa0) && (opcode <= 0xa3))
		{
			p += 4;
		}
	}
	else
	{
		if ((opcode == 0x9a) || (opcode == 0xea))
		{
			p += 6;
		}
		if ((opcode >= 0xa0) && (opcode <= 0xa3))
		{
			p += 4;
		}
	}
	mod -= 1;
	switch (mod)
	{
	case 0:
		p++;
		break;
	case 1:
		p += 2;
		break;
	case 2:
		if (is_64w&&is_movIv)
		{
			p += 8;
		}
		else
		{
			p += 2 * (is_16 == 0) + 2;
		}
		break;
	case 3:
		p += 3;
		default:
		break;
	}
	if ((uint32_t)(p - code) > length)
	{
		return -1;
	}
	return p - code;
}
